;; # Hello, Clerk üëã
^{:nextjournal.clerk/visibility #{:hide-ns}}
(ns clerk
  (:require [nextjournal.clerk :as clerk]
            [babashka.fs :as fs]))

;; Clerk enables a *rich*, local-first notebook experience using
;; standard Clojure namespaces and markdown files with Clojure code
;; fences. For example, this text is rendered from some markdown
;; written in a comment block.

;; If you start a file watcher on a directory tree containing `clj` or
;; `md` files, Clerk will automatically watch for changes and show you
;; the must recently changed one. To make this performant enough to
;; feel good, Clerk caches computations it must perform while
;; evaluating the forms in any given file. Likewise, to make sure we
;; don't send too much data to the browser we perform pagination by
;; default on data returned by your computations.

;; ## Pagination

;; So, for example, the infinite sequence returned by the call to
;; `(range)` will be loaded a little bit at a time as you click on the
;; results. (Note the little underscore under the first paren, it lets
;; you switch this sequence to a vertical rather than horizontal
;; view).
(range)

;; Opaque objects are printed as they would be in the Clojure REPL,
;; like so:
(def notebooks
  (clojure.java.io/file "notebooks"))

;; ... and you can leave a form at the top-level like this to examine
;; the result of evaluating it, though you'd probably use your live
;; programming environment to do this most of the time.
(into #{} (map str) (file-seq notebooks))

;; Sometimes you don't want Clerk to cache a form. You can turn off
;; caching for a form by placing a piece of metadata before it like
;; this:
^:nextjournal.clerk/no-cache (shuffle (range 100))

;; Another useful technique is to put an instant marking the last time
;; a form was run. This way you can update this result at any time by
;; updating the instant.
(let [last-run #inst "2021-12-01T16:40:56.048896Z"] ; TODO broken?
  (shuffle (range 100)))

;; Like other objects, `UUID`s and `inst`s are rendered as they would
;; be in the REPL.
(take 10
      (repeatedly (fn []
                    {:name (str
                            (rand-nth ["Oscar" "Karen" "Vlad" "Rebecca" "Conrad"]) " "
                            (rand-nth ["Miller" "Stasƒçnyk" "Ronin" "Meyer" "Black"]))
                     :role (rand-nth [:admin :operator :manager :programmer :designer])
                     :id (java.util.UUID/randomUUID)
                     :created-at #inst "2021"})))

;; Clerk also supports unicode, of course.
{:hello "üëã world" :tacos (map (comp #(map (constantly 'üåÆ) %) range) (range 1 100))}

;; ## üëÅ Clerk Viewer API

;; In addition to these basic viewers for Clojure data structures,
;; Clerk comes with a set of built-in viewers for many kinds of
;; things, and a moldable viewer API that can be extended while you
;; work.

;; ### üß© Built-in Viewers

;; #### üìë Markdown

;; The same Markdown support Clerk uses for comment blocks is also available programmatically:
(clerk/md (clojure.string/join "\n" (map #(str "* _Item_ " (inc %)) (range 3))))

;; #### üëæ Code

;; There's a code viewer uses that
;; [clojure-mode](https://nextjournal.github.io/clojure-mode/) for
;; syntax highlighting.
(clerk/code (macroexpand '(when test
                            expression-1
                            expression-2)))

;; #### üßÆ TeX

;; All comment blocks can contain TeX (we use
;; [KaTeX](https://katex.org/) under the covers), and you can also
;; call the TeX viewer programmatically. Here, for example, are
;; Maxwell's equations in differential form:
(clerk/tex "
\\begin{alignedat}{2}
  \\nabla\\cdot\\vec{E} = \\frac{\\rho}{\\varepsilon_0} & \\qquad \\text{Gauss' Law} \\\\
  \\nabla\\cdot\\vec{B} = 0 & \\qquad \\text{Gauss' Law ($\\vec{B}$ Fields)} \\\\
  \\nabla\\times\\vec{E} = -\\frac{\\partial \\vec{B}}{\\partial t} & \\qquad \\text{Faraday's Law} \\\\
  \\nabla\\times\\vec{B} = \\mu_0\\vec{J}+\\mu_0\\varepsilon_0\\frac{\\partial\\vec{E}}{\\partial t} & \\qquad \\text{Ampere's Law}
\\end{alignedat}
")

;; #### üï∏ Hiccup

;; The `html` viewer interprets `hiccup` when passed a vector. (This
;; can be quite useful for building arbitrary layouts in your
;; notebooks.)
(clerk/html [:table
             [:tr [:td "‚ó§"] [:td "‚ó•"]]
             [:tr [:td "‚óâ"] [:td "‚óâ"]]
             [:tr [:td "‚ó£"] [:td "‚ó¢"]]])

;; Alternatively you can also just pass an HTML string, perhaps
;; generated by your code.
(clerk/html "‚ÄúA brilliant solution to the wrong problem can be worse than no solution at all: solve the correct problem.‚Äù<br/><em>Donald Norman</em>.")

;; #### üìä Plotly

;; Clerk also has built-in support for Plotly's low-ceremony plotting.
(clerk/plotly {:data [{:z [[1 2 3] [3 2 1]] :type "surface"}]})

;; #### üìà Vega Lite

;; But we also have Vega Lite for those who prefer that grammar.
(clerk/vl {:width 650 :height 400 :data {:url "https://vega.github.io/vega-datasets/data/us-10m.json"
                                         :format {:type "topojson" :feature "counties"}}
           :transform [{:lookup "id" :from {:data {:url "https://vega.github.io/vega-datasets/data/unemployment.tsv"}
                                            :key "id" :fields ["rate"]}}]
           :projection {:type "albersUsa"} :mark "geoshape" :encoding {:color {:field "rate" :type "quantitative"}}})

;; ### üöÄ Extensibility

;; In addition to these defaults, you can also attach a custom viewer
;; to any form. Here we make our own little viewer to greet James
;; Clerk Maxwell:
(clerk/with-viewer #(v/html [:div "Greetings to " [:strong %] "!"])
  "James Maxwell Clerk")

;; But we can do more interesting things, like matching numbers and
;; using them to produce headings, or turning each string into a
;; paragraph.
(clerk/with-viewers [{:pred number?
                      :render-fn #(v/html [(keyword (str "h" %)) (str "Heading " %)])}
                     {:pred string?
                      :render-fn #(v/html [:p %])}]
  [1 "To begin at the beginning:"
   2 "It is Spring, moonless night in the small town, starless and bible-black,"
   3 "the cobblestreets silent and the hunched,"
   4 "courters'-and- rabbits' wood limping invisible"
   5 "down to the sloeblack, slow, black, crowblack, fishingboat-bobbing sea."])

;; Or you could use black and white squares to render numbers:
^::clerk/no-cache
(clerk/with-viewers [{:pred number?
                      :render-fn #(v/html [:div.inline-block {:style {:width 16 :height 16}
                                                              :class (if (pos? %) "bg-black" "bg-white border-solid border-2 border-black")}])}]
  (take 10 (repeatedly #(rand-int 2))))

;; Or build your own colour parser and use it to generate swatches:
(clerk/with-viewers
  [{:pred #(and (string? %)
                (re-matches
                 (re-pattern
                  (str "(?i)"
                       "(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|"
                       "(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))")) %))
    :render-fn #(v/html [:div.inline-block.rounded-sm.shadow
                         {:style {:width 16
                                  :height 16
                                  :border "1px solid rgba(0,0,0,.2)"
                                  :background-color %}}])}]
  ["#571845"
   "rgb(144,12,62)"
   "rgba(199,0,57,1.0)"
   "hsl(11,100%,60%)"
   "hsla(46, 97%, 48%, 1.000)"])

;; This is just a taste of what's possible using Clerk. Take a look in
;; the `notebooks` directory to see a collection of worked examples in
;; different domains.

;; And don't forget to let us know how it goes!
